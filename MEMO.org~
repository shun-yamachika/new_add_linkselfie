# add_linkselfie – I/O & Loops memo

## main.py
**Inputs**
- 実験パラメータ: `budget_list`, `scheduler_names`, `noise_model_names`, `node_path_list`, `importance_list`, `bounces`, `repeat`

**Outputs**
- `evaluation.py` の各関数を並列実行 → `outputs/*.pdf` を生成

**Loops**
- `for noise_model in noise_model_names:`
  - `Pool.apply_async(...)` で
    - `plot_accuracy_vs_budget(...)`
    - `plot_value_vs_used(...)`
    - `plot_value_vs_budget_target(...)`
  - 最後に `join()` して回収

---

## evaluation.py
### plot_accuracy_vs_budget(...)
**Inputs**: 予算列・スケジューラ名・ノイズモデル・ノード/重要度・`bounces`・`repeat`  
**Outputs**: `outputs/plot_accuracy_vs_budget_{noise_model}.pdf`  
**Loops**:
- `for C_total in budget_list:`  
  - `for r in range(repeat):`
    - トポロジ生成（ペアごとに fidelity リスト）
    - `for name in scheduler_names:` → `run_scheduler(...)`
      - 正答率を集計（平均）

### plot_value_vs_used(...)
**Inputs**: 同上（`return_details=True` で呼ぶ）  
**Outputs**: `outputs/plot_value_vs_used_{noise_model}.pdf`（x=実消費コスト平均）  
**Loops**:
- `for C_total in budget_list:`
  - `for r in range(repeat):`
    - トポロジ生成
    - `for name in scheduler_names:` → `run_scheduler(..., return_details=True)`
      - 受け取った `alloc_by_path` と `est_fid_by_path` で価値を合成
      - `total_cost` を保持

### plot_value_vs_budget_target(...)
**Inputs**: 同上（`return_details=True` で呼ぶ）  
**Outputs**: `outputs/plot_value_vs_budget_target_{noise_model}.pdf`（x=目標予算）  
**Loops**: `plot_value_vs_used` と同一（プロット時の x だけ `budget_list`）

---

## schedulers/__init__.py
**Inputs**: `node_path_list`, `importance_list`, `scheduler_name`, `bounces`, `C_total`, `network_generator`, `return_details`  
**Outputs**:
- `"LNaive"` → `lnaive_budget_scheduler(...)` の戻り値をそのまま返す  
- `"Greedy"` → `greedy_budget_scheduler(...)` の戻り値をそのまま返す  
**Loops**: なし（ディスパッチのみ）

---

## schedulers/lnaive_scheduler.py
**Inputs**: `node_path_list`, `importance_list`, `bounces`, `C_total`, `network_generator`, `return_details=False`  
**Outputs**:
- `per_pair_results: List[(correct: bool, cost: int, best_fid: float|None)]`
- `total_cost: int`
- `per_pair_details: List[{alloc_by_path, est_fid_by_path}]`（`return_details=True` のとき）
**Loops**:
- `for pair_idx, path_num in enumerate(node_path_list):`
  - 各ペアに等分配した予算で `naive_network_benchmarking_with_budget(...)` を1回呼ぶ

---

## schedulers/greedy_scheduler.py
**Inputs**: `node_path_list`, `importance_list`, `bounces`, `C_total`, `network_generator`, `C_initial_per_pair=40`, `return_details=False`  
**Outputs**: 上記 LNaive と同形（初期＋残余の詳細はマージ）  
**Loops**:
1) **初期プローブ**: `for pair_idx, path_num in enumerate(node_path_list):`
   - 小予算で `lonline_network_benchmarking(...)` を実行
2) **優先度計算**: `score = importance * estimated_fidelity` を全ペアで算出し降順ソート
3) **残余配分**: `for pair_idx in sorted_indices:` 残り予算を順に集中投資（各回 `lonline_network_benchmarking(...)`）

---

## schedulers/lonline_nb.py （アルゴ：L-Online）
**Inputs**: `network`, `path_list`, `bounces`, `C_budget`, `return_details=False`  
**Outputs**:
- `return_details=False`: `(correct: bool, cost: int, best_fid: float|None)`
- `return_details=True` : 上に加え `alloc_by_path: {path_id:int}`, `est_fid_by_path: {path_id:float}`
**Loops**:
- `while cost < C_budget and len(candidate_set) > 1:`
  - ラウンド `s` のサンプル数 `Ns` を決定
  - `for path in candidate_set:`（予算が入る分だけ計測）
  - 連続削除ルールで候補を間引き

---

## schedulers/lnaive_nb.py （アルゴ：L-Naive）
**Inputs**: `network`, `path_list`, `bounces`, `C_budget`, `return_details=False`  
**Outputs**: L-Online と同形（3タプル/5タプル）  
**Loops**:
- `Ns = floor(C_budget / (len(path_list) * per_sample_cost))` を計算
- `for path in path_list:` 各経路を同じ回数 `Ns` 測定して推定更新
