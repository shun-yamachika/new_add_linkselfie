def naive_network_benchmarking(network, path_list, bounces, sample_times):
    fidelity = {}
    cost = 0

    # ガード: サンプル0なら何もしない
    if sample_times and not any(sample_times.values()):
        return 0, 0, None

    for path in path_list:
        p, bounces_num = network.benchmark_path(path, bounces, sample_times)
        fidelity[path] = p + (1 - p) / 2
        cost += bounces_num

    if not fidelity:               # ガード: path_list空など
        return 0, cost, None

    best_path = max(fidelity, key=fidelity.get)
    correctness = (best_path == network.best_path)
    best_path_fidelity = fidelity[best_path]
    return correctness, cost, best_path_fidelity
